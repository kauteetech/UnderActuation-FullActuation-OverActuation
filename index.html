<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot Actuation Concepts (Improved Animations)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 20px;
        }
        h1 {
            color: #333;
        }
        .concept-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            margin-top: 30px;
        }
        .scenario {
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 20px;
            text-align: center;
            width: 380px; /* Wider to accommodate formulas and complex animations */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .scenario h2 {
            color: #0056b3;
            margin-top: 0;
            font-size: 1.3em;
        }
        .animation-area {
            width: 360px; /* Adjusted width */
            height: 180px; /* Increased height for more complex movements */
            border: 2px solid #ccc;
            margin: 15px auto;
            position: relative;
            overflow: hidden;
            background-color: #e9e9e9;
        }

        /* General Robot styling */
        .robot-body {
            position: absolute;
            background-color: #ff5733;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8em;
            font-weight: bold;
        }
        .target {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 2px dashed #007bff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #007bff;
            font-size: 0.8em;
        }

        /* Fully Actuated Specifics */
        #fullyActuatedRobot {
            width: 40px;
            height: 40px;
            background-color: #f0ad4e;
            top: 70px;
            left: 20px;
        }
        .fully-actuated-target {
            top: 70px;
            left: 310px;
        }

        /* Underactuated Specifics (Cart-Pendulum) */
        #cart {
            width: 60px;
            height: 20px;
            background-color: #555;
            position: absolute;
            bottom: 20px; /* On the "ground" */
            left: calc(50% - 30px); /* Center initially */
        }
        #pendulum-rod {
            width: 4px;
            height: 80px;
            background-color: #888;
            position: absolute;
            transform-origin: bottom center;
            bottom: 40px; /* Above the cart */
            left: calc(50% - 2px);
            transition: none; /* Controlled by JS */
        }
        #pendulum-bob {
            width: 20px;
            height: 20px;
            background-color: #33aaff; /* Blue for underactuated */
            border-radius: 50%;
            position: absolute;
            top: -10px; /* Relative to rod */
            left: -8px; /* Relative to rod */
        }
        #underactuatedDesc {
            font-size: 0.85em; /* Smaller text for more info */
        }

        /* Overactuated Specifics (Drone) */
        #droneBody {
            width: 60px;
            height: 10px;
            background-color: #5cb85c;
            position: absolute;
            top: 50px;
            left: calc(50% - 30px);
            border-radius: 3px;
        }
        .propeller {
            width: 15px;
            height: 5px;
            background-color: #333;
            position: absolute;
            border-radius: 2px;
            top: -10px; /* Above body */
            transform-origin: center center; /* For rotation */
            animation: spin 0.5s linear infinite;
        }
        .propeller.failed {
            background-color: #ff0000;
            animation: none; /* Stop spinning */
        }
        #prop1 { left: -10px; }
        #prop2 { right: -10px; }
        #prop3 { left: 45px; }
        #prop4 { right: 45px; }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Common Styling for Formulas */
        p {
            font-size: 0.9em;
            color: #555;
            flex-grow: 1;
            margin-bottom: 10px;
        }
        .math-formula {
            font-family: serif;
            margin: 10px 0;
            color: #333;
            font-size: 1.1em;
            border-top: 1px dashed #eee;
            padding-top: 10px;
            min-height: 80px; /* Ensure space for formulas */
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: auto;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <h1>Robot Actuation Concepts: Visualized</h1>
    <p>Explore the difference between fully, under, and overactuated systems. **(Requires internet connection for formulas)**</p>

    <div class="concept-container">

        <div class="scenario">
            <h2>Fully Actuated System</h2>
            <div class="animation-area">
                <div class="robot-body" id="fullyActuatedRobot">OmniCar</div>
                <div class="target fully-actuated-target">Target</div>
            </div>
            <p>
                A **fully actuated** system has an equal number of independent **actuators** (motors, thrusters, etc.) as its degrees of freedom (DoFs). This means you have direct, independent control over every way the robot can move.
            </p>
            <p style="font-style: italic;">
                **Real-world example:** An **omnidirectional mobile robot** (like some forklifts or factory robots with special wheels) can move directly sideways, forward, backward, or rotate, all at the same time, without needing to turn its wheels or body. It has a motor for each of these independent motions.
            </p>
            <div class="math-formula">
                **Condition:** $ n_{\text{actuators}} = n_{\text{degrees of freedom}} $
                <br>
                **Control Analogy:** Imagine having a separate joystick for every possible movement.
            </div>
            <button onclick="startFullyActuatedAnimation()">Animate Fully Actuated</button>
        </div>

        <div class="scenario">
            <h2>Underactuated System</h2>
            <div class="animation-area">
                <div id="cart" class="robot-body">Cart</div>
                <div id="pendulum-rod">
                    <div id="pendulum-bob">Pendulum</div>
                </div>
            </div>
            <p>
                An **underactuated** system has **fewer** independent actuators than its degrees of freedom. This means some motions can't be directly controlled; you have to influence them indirectly by moving the parts you *can* control.
            </p>
            <p style="font-style: italic;">
                **Real-world example:** A **bicycle** has many ways to move (forward, turn, lean, balance), but you primarily control only two things: the pedaling (forward motion) and the handlebars (steering). You don't have a direct "balance motor"; you balance by moving the handlebars and shifting your body, which indirectly affects the bike's lean.
            </p>
            <div class="math-formula">
                **Condition:** $ n_{\text{actuators}} < n_{\text{degrees of freedom}} $
                <br>
                **Control Analogy:** Like balancing a stick on your finger â€“ you only move your finger, but you indirectly control the stick's tilt.
            </div>
            <button onclick="startUnderactuatedAnimation()">Animate Underactuated</button>
        </div>

        <div class="scenario">
            <h2>Overactuated System</h2>
            <div class="animation-area">
                <div id="droneBody" class="robot-body">
                    <div class="propeller" id="prop1"></div>
                    <div class="propeller" id="prop2"></div>
                    <div class="propeller" id="prop3"></div>
                    <div class="propeller" id="prop4"></div>
                </div>
                <div class="target" style="top: 130px; left: 310px;">Landing</div>
            </div>
            <p>
                An **overactuated** system has **more** independent actuators than its degrees of freedom. This "extra" control ability (redundancy) is often used for reliability, safety, or to achieve tasks more efficiently.
            </p>
            <p style="font-style: italic;">
                **Real-world example:** Most **quadrotor drones** (like the ones you see delivering packages or filming) have 4 propellers. To move in 3D space and rotate (6 degrees of freedom), they technically only *need* 4 perfectly controlled propellers. However, many larger drones might have 6 or 8 propellers (**hexacopters/octocopters**). If one or two propellers fail, the drone can often still land safely using the remaining ones.
            </p>
            <div class="math-formula">
                **Condition:** $ n_{\text{actuators}} > n_{\text{degrees of freedom}} $
                <br>
                **Benefit:** Improved fault tolerance, redundancy.
            </div>
            <button onclick="startOveractuatedAnimation()">Animate Overactuated</button>
        </div>

    </div>

    <script>
        // --- Animation Functions ---

        // Helper to reset a robot's styling
        function resetElement(elementId, initialLeft, initialTop, initialTransform = 'none') {
            const el = document.getElementById(elementId);
            if (!el) return;
            el.style.transition = 'none';
            el.style.left = initialLeft !== undefined ? initialLeft + 'px' : el.style.left;
            el.style.top = initialTop !== undefined ? initialTop + 'px' : el.style.top;
            el.style.transform = initialTransform;
            void el.offsetWidth; // Trigger reflow
        }

        // --- Fully Actuated Animation (Omni-directional movement) ---
        function startFullyActuatedAnimation() {
            const robot = document.getElementById('fullyActuatedRobot');
            resetElement('fullyActuatedRobot', 20, 70);

            setTimeout(() => {
                robot.style.transition = 'all 2s ease-in-out';
                robot.style.left = '310px';
                robot.style.top = '70px';
                // Imagine it can move diagonally, directly to the target.
            }, 50);
        }

        // --- Underactuated Animation (Cart moving, pendulum swinging) ---
        let pendulumInterval;
        function startUnderactuatedAnimation() {
            const cart = document.getElementById('cart');
            const pendulumRod = document.getElementById('pendulum-rod');
            const pendulumBob = document.getElementById('pendulum-bob');

            // Reset
            clearInterval(pendulumInterval);
            resetElement('cart', 150, 140);
            resetElement('pendulum-rod', 178, 60, 'rotate(0deg)'); // Adjust x for rod center, bottom for pivot

            let cartX = 150;
            let pendulumAngle = 0; // degrees, 0 = straight down
            let pendulumAngularVelocity = 0;

            const dt = 0.05; // Time step for simulation
            const g = 9.81; // Gravity
            const L = 80; // Pendulum rod length (pixels)

            // Simple movement of the cart to show it affects the pendulum
            let direction = 1; // 1 for right, -1 for left
            let moveCounter = 0; // To limit total moves

            pendulumInterval = setInterval(() => {
                const sinTheta = Math.sin(pendulumAngle * Math.PI / 180);
                const cosTheta = Math.cos(pendulumAngle * Math.PI / 180);

                // Apply a simple oscillating force to the cart
                let u = direction * 50 * Math.sin(Date.now() / 500); // Oscillating force

                // Simplified pendulum dynamics
                const ddtheta = (-g / L) * sinTheta; // Gravity's effect on pendulum
                // Now, add the effect of cart's acceleration on the pendulum
                // This is a simplified coupling:
                const cartAccelerationEffect = -(u / (100 + 1)) * (cosTheta / L); // Arbitrary cart mass 100 for effect
                pendulumAngularVelocity += (ddtheta + cartAccelerationEffect) * dt;
                pendulumAngle += pendulumAngularVelocity * dt * (180 / Math.PI); // Convert to degrees

                // Move the cart left and right
                cartX += direction * 2; // Constant cart speed
                if (cartX > 280 || cartX < 20) {
                    direction *= -1; // Reverse direction
                    moveCounter++;
                }

                cart.style.left = cartX + 'px';
                pendulumRod.style.left = (cartX + 28) + 'px'; // Keep rod centered on cart
                pendulumRod.style.transform = `rotate(${pendulumAngle}deg)`;

                if (moveCounter >= 5) { // Stop after 5 back-and-forth movements
                    clearInterval(pendulumInterval);
                    // Reset to initial state after animation
                    setTimeout(() => {
                        resetElement('cart', 150, 140);
                        resetElement('pendulum-rod', 178, 60, 'rotate(0deg)');
                    }, 500);
                }

            }, dt * 1000);
        }

        // --- Overactuated Animation (Drone with simulated failure and recovery) ---
        let droneAnimationInterval;
        function startOveractuatedAnimation() {
            const droneBody = document.getElementById('droneBody');
            const prop1 = document.getElementById('prop1');
            const prop2 = document.getElementById('prop2');
            const prop3 = document.getElementById('prop3');
            const prop4 = document.getElementById('prop4');

            // Reset state
            clearInterval(droneAnimationInterval);
            resetElement('droneBody', 150, 50);
            [prop1, prop2, prop3, prop4].forEach(p => {
                p.classList.remove('failed');
                p.style.display = 'block'; // Ensure all props are visible
                p.style.animation = 'spin 0.5s linear infinite'; // Restart animation
            });

            // Phase 1: Initial stable flight
            droneBody.style.transition = 'all 3s ease-in-out';
            droneBody.style.top = '100px'; // Hover down slightly
            droneBody.style.left = '50px'; // Move left

            // Phase 2: Propeller failure
            setTimeout(() => {
                prop4.classList.add('failed'); // Prop 4 fails
                prop4.style.display = 'none'; // Visually show it's gone
                prop4.style.animation = 'none'; // Stop its spin animation

                // Drone momentarily dips and wobbles (simulated)
                droneBody.style.transition = 'all 1s linear';
                droneBody.style.top = '120px'; // Dip
                droneBody.style.transform = 'rotate(5deg)'; // Wobble

                // Phase 3: Recovery using remaining propellers
                setTimeout(() => {
                    if (prop4.classList.contains('failed')) { // Only if still failed
                        droneBody.style.transition = 'all 2s ease-out';
                        droneBody.style.top = '130px'; // Move towards landing target
                        droneBody.style.left = '310px';
                        droneBody.style.transform = 'rotate(0deg)'; // Recover orientation
                    }
                }, 1000); // 1 sec after failure (4s from start)

            }, 3000); // Propeller fails after 3 seconds of flight

            // Phase 4: Reset
            setTimeout(() => {
                resetElement('droneBody', 150, 50);
                [prop1, prop2, prop3, prop4].forEach(p => {
                    p.classList.remove('failed');
                    p.style.display = 'block';
                    p.style.animation = 'spin 0.5s linear infinite';
                });
            }, 8000); // Reset after 8 seconds total
        }
    </script>
</body>
</html>
